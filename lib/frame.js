/**
 * Constructs a Frame object.
 *
 * Frame instances created with this constructor are invalid.
 * Get valid Frame objects by calling the
 * {@link Leap.Controller#frame}() function.
 *
 * @class Leap.Frame
 * @classdesc
 * The Frame class represents a set of hand and finger tracking data detected
 * in a single frame.
 *
 * The Leap detects hands, fingers and tools within the tracking area, reporting
 * their positions, orientations and motions in frames at the Leap frame rate.
 *
 * Access Frame objects using the {@link Leap.Controller#frame}() function.
 *
 * @borrows Motion#translation as #translation
 * @borrows Motion#matrix as #matrix
 * @borrows Motion#rotationAxis as #rotationAxis
 * @borrows Motion#rotationAngle as #rotationAngle
 * @borrows Motion#rotationMatrix as #rotationMatrix
 * @borrows Motion#scaleFactor as #scaleFactor
 */
var Frame = exports.Frame = function(data) {
  /**
   * Reports whether this Frame instance is valid.
   *
   * A valid Frame is one generated by the Controller object that contains
   * tracking data for all detected entities. An invalid Frame contains no
   * actual tracking data, but you can call its functions without risk of a
   * undefined object exception. The invalid Frame mechanism makes it more
   * convenient to track individual data across the frame history. For example,
   * you can invoke:
   *
   * ```javascript
   * var finger = controller.frame(n).finger(fingerID);
   * ```
   *
   * for an arbitrary Frame history value, "n", without first checking whether
   * frame(n) returned a null object. (You should still check that the
   * returned Finger instance is valid.)
   *
   * @member Leap.Frame.prototype.valid
   * @type {Boolean}
   */
  this.valid = true
  /**
   * A unique ID for this Frame. Consecutive frames processed by the Leap
   * have consecutive increasing values.
   * @member Leap.Frame.prototype.id
   * @type {String}
   */
  this.id = data.id
  /**
   * The frame capture time in microseconds elapsed since the Leap started.
   * @member Leap.Frame.prototype.timestamp
   * @type {Number}
   */
  this.timestamp = data.timestamp
  /**
   * The list of Hand objects detected in this frame, given in arbitrary order.
   * The list can be empty if no hands are detected.
   *
   * @member Leap.Frame.prototype.hands[]
   * @type {Leap.Hand}
   */
  this.hands = []
  this.handsMap = {}
  /**
   * The list of Pointable objects (fingers and tools) detected in this frame,
   * given in arbitrary order. The list can be empty if no fingers or tools are
   * detected.
   *
   * @member Leap.Frame.prototype.pointables[]
   * @type {Leap.Pointable}
   */
  this.pointables = []
  /**
   * The list of Tool objects detected in this frame, given in arbitrary order.
   * The list can be empty if no tools are detected.
   *
   * @member Leap.Frame.prototype.tools[]
   * @type {Leap.Pointable}
   */
  this.tools = []
  /**
   * The list of Finger objects detected in this frame, given in arbitrary order.
   * The list can be empty if no fingers are detected.
   * @member Leap.Frame.prototype.fingers[]
   * @type {Leap.Pointable}
   */
  this.fingers = []
  this.pointablesMap = {}
  this._translation = data.t;
  this.rotation = data.r;
  this._scaleFactor = data.s;
  var handMap = {}
  for (var handIdx = 0, handCount = data.hands.length; handIdx != handCount; handIdx++) {
    var hand = new window.Leap.Hand(data.hands[handIdx]);
    hand.frame = this;
    this.hands.push(hand)
    this.handsMap[hand.id] = hand
    handMap[hand.id] = handIdx
  }
  for (var pointableIdx = 0, pointableCount = data.pointables.length; pointableIdx != pointableCount; pointableIdx++) {
    var pointable = new window.Leap.Pointable(data.pointables[pointableIdx]);
    pointable.frame = this;
    this.pointables.push(pointable);
    this.pointablesMap[pointable.id] = pointable;
    (pointable.tool ? this.tools : this.fingers).push(pointable);
    if (pointable.handId && handMap.hasOwnProperty(pointable.handId)) {
      var hand = this.hands[handMap[pointable.handId]]
      hand.pointables.push(pointable);
      (pointable.tool ? hand.tools : hand.fingers).push(pointable);
    }
  }
  Leap.extend(Frame.prototype, Motion)
}

/**
 * The tool with the specified ID in this frame.
 *
 * Use the Frame tool() function to retrieve a tool from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Pointable object, but if no tool
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a tool is lost and subsequently
 * regained, the new Pointable object representing that tool may have a
 * different ID than that representing the tool in an earlier frame.
 *
 * @method Leap.Frame.prototype.tool
 * @param {String} id The ID value of a Tool object from a previous frame.
 * @returns {Leap.Pointable | Leap.Pointable.Invalid} The tool with the
 * matching ID if one exists in this frame; otherwise, an invalid Pointable object
 * is returned.
 */
Frame.prototype.tool = function(id) {
  var pointable = this.pointable(id)
  return pointable.tool ? pointable : Pointable.Invalid
}

/**
 * The Pointable object with the specified ID in this frame.
 *
 * Use the Frame pointable() function to retrieve the Pointable object from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Pointable object, but if no finger or tool
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a finger or tool is lost and subsequently
 * regained, the new Pointable object representing that finger or tool may have
 * a different ID than that representing the finger or tool in an earlier frame.
 *
 * @method Leap.Frame.prototype.pointable
 * @param {String} id The ID value of a Pointable object from a previous frame.
 * @returns {Leap.Pointable | Leap.Pointable.Invalid} The Pointable object with
 * the matching ID if one exists in this frame;
 * otherwise, an invalid Pointable object is returned.
 */
Frame.prototype.pointable = function(id) {
  return this.pointablesMap[id] || Pointable.Invalid
}

/**
 * The finger with the specified ID in this frame.
 *
 * Use the Frame finger() function to retrieve the finger from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Finger object, but if no finger
 * with the specified ID is present, an invalid Pointable object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a finger is lost and subsequently
 * regained, the new Pointable object representing that physical finger may have
 * a different ID than that representing the finger in an earlier frame.
 *
 * @method Leap.Frame.prototype.finger
 * @param {String} id The ID value of a finger from a previous frame.
 * @returns {Leap.Pointable | Leap.Pointable.Invalid} The finger with the
 * matching ID if one exists in this frame; otherwise, an invalid Pointable
 * object is returned.
 */
Frame.prototype.finger = function(id) {
  var pointable = this.pointable(id)
  return !pointable.tool ? pointable : Pointable.Invalid
}

/**
 * The Hand object with the specified ID in this frame.
 *
 * Use the Frame hand() function to retrieve the Hand object from
 * this frame using an ID value obtained from a previous frame.
 * This function always returns a Hand object, but if no hand
 * with the specified ID is present, an invalid Hand object is returned.
 *
 * Note that ID values persist across frames, but only until tracking of a
 * particular object is lost. If tracking of a hand is lost and subsequently
 * regained, the new Hand object representing that physical hand may have
 * a different ID than that representing the physical hand in an earlier frame.
 *
 * @method Leap.Frame.prototype.hand
 * @param {String} id The ID value of a Hand object from a previous frame.
 * @returns {Leap.Hand | Leap.Hand.Invalid} The Hand object with the matching
 * ID if one exists in this frame; otherwise, an invalid Hand object is returned.
 */
Frame.prototype.hand = function(id) {
  return this.handsMap[id] || Hand.Invalid;
}

/**
 * A string containing a brief, human readable description of the Frame object.
 *
 * @method Leap.Frame.prototype.toString
 * @returns {String} A brief description of this frame.
 */
Frame.prototype.toString = function() {
  return "frame id:"+this.id+" timestamp:"+this.timestamp+" hands("+this.hands.length+") pointables("+this.pointables.length+")"
}

/**
 * Returns a JSON-formatted string containing the hands and pointables in this
 * frame.
 *
 * @method Leap.Frame.prototype.dump
 * @returns {String} A JSON-formatted string.
 */
Frame.prototype.dump = function() {
  var out = '';
  out += "\nHands:\n"
  for (var handIdx = 0, handCount = this.hands.length; handIdx != handCount; handIdx++) {
    out += "  "+ this.hands[handIdx].toString() + "\n"
  }
  out += "Pointables:\n"
    for (var pointableIdx = 0, pointableCount = this.pointables.length; pointableIdx != pointableCount; pointableIdx++) {
    out += "  "+ this.pointables[pointableIdx].toString() + "\n"
  }
  out += "Raw JSON:\n";
  out += this.toString();
  return out;
}

/**
 * An invalid Frame object.
 *
 * You can use this invalid Frame in comparisons testing
 * whether a given Frame instance is valid or invalid. (You can also check the
 * {@link Leap.Frame#valid} property.)
 *
 * @constant
 * @type {Leap.Frame}
 * @name Leap.Frame.Invalid
 */
Frame.Invalid = {
  valid: false,
  hands: [],
  fingers: [],
  pointables: [],
  pointable: function() { return window.Leap.Pointable.Invalid },
  finger: function() { return window.Leap.Pointable.Invalid },
  hand: function() { return window.Leap.Hand.Invalid },
  toString: function() { return "invalid frame" },
  dump: function() { return this.toString() }
}

Leap.extend(Frame.Invalid, Motion)
